# 函数式编程(Functional Programming)

## 什么是函数式编程

在 Wikipedia 中有如下说明
> 函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程典范，它将计算机运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。

> 比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。

简而言之，函数式编程是通过编写纯函数，避免共享状态，可变数据和副作用来构建程序的过程。相比于面向对象编程通常将程序中的状态与对象中的方法共享和共处；函数式编程更多的像是陈述型编程而不是命令型编程，其程序中的状态通过纯函数来交互。

函数式编程是一种编程思想，也就意味着它不仅仅适用于JavaScript中。这种思想的核心就是使代码更加清晰，可预测性强，也更方便于测试。

因此，对于函数式编程，我们需要了解以下几个核心点：

* 纯函数(Pure functions)
* 函数组合/复合函数(Function composition)
* 避免共享状态(Avoid shared state)
* 避免可变状态(Avoid mutation state)
* 避免副作用(Avoid side effects)

## 纯函数(Pure Functions)

在Wikipedia中关于纯函数的说明中，只要符合一下两点的其中一点即可认为可能是纯函数
> 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关。

> 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。

简单点来说就两点：

* 给出相同的输入，总是会得到相同的输出
* 无任何副作用

## 函数组合/复合函数(Function composition)

函数组合是指组合两个或多个函数以产生新函数或执行某些计算的过程。譬如在JavaScript中函数f 与 函数 g 的组合就像 `f(g(x))` 。

在数学中，复合函数也可以简单解释为：复合两个函数是把两个函数链接在一起的过程，内函数的输出就是外函数的输入。以此类推，多个函数的复合也一样。

其实在我们的实际开发中或多或少使用到了函数组合。譬如

```js
const result = students.filter(item => item.passed).map(item => item.name)
```

## 共享状态(Shared State)

共享状态可以是任何变量、对象甚至是存在于共同作用域下的内存空间，或者是作用域在作用域之间传递的属性。我们在面向对象编程中经常可以看到通过添加对象属性来达到状态共享的效果。

函数式编程要求避免共享状态，通过依赖于不可变的数据结构和纯计算来从现有数据中获取新数据。这个理念在 `redux` 中有着深刻的体现。

共享状态的问题在于，为了理解函数的效果，你必须知道函数使用或影响每个共享状态的完整过程。要不然你基本无法快速理解一个函数到时是干嘛的。

接下来我将会举例子说明共享状态的缺点。

譬如你需要存储一个 `user` 对象，这个对象包含了头像等个人信息。你的 `saveUser()` 函数可以发送一个请求给服务器来达到目的。当你发送请求时，用户使用 `updateAvatar()` 请求改变了他们的头像，然后又点击触发了一次 `saveUser()` 请求。保存后，服务器会返回用户最新的个人信息，然后前端拿到请求得到的数据渲染页面。

现在意外发生了，第二个请求（`saveUser()`）在第一个请求（`updateAvatar()`）前先完成了并返回了数据；这时候页面上的个人信息仍然是旧的。

还有个比较常见的问题，在执行函数是按照不同的顺序可能会导致得到非预期的结果，这主要是共享状态的函数基本都与调用的时序有比较大的关系。

调用顺序导致结果不一致的例子：
```js
const x = {
  val: 2
}

const x1 = () => x.val += 1

const x2 = () => x.val *= 2 

x1()  // 改变了 x.val
x2()  // 改变了 x.val

console.log(x.val)  // 6

const y = {
  val: 2
}

const y1 = () => y.val += 1

const y2 = () => y.val *= 2

y2()  // 改变了 y.val
y1()  // 改变了 y.val

console.log(y.val)  // 5
```

避免共享状态的例子：

```js
const x = {
  val: 2
}

// 通过 Object.assign 来达到深复制的效果。
const x1 = x => Object.assign({}, x, { val: x.val + 1})

const x2 = x => Object.assign({}, x , { val: x.val * 2})

console.log(x1(x2(x)).val, x.val)  // 5 2

const y = {
  val: 2
}

// 因为以上函数是不改变任何数据的，无论我们调用它多少次，用任何顺序都得到相同的结果。
x2(y)
x1(y)


console.log(x1(x2(y)).val, y.val)  // 5 2
```
以上例子说明，避免共享状态可以避免很多类似函数调用顺序导致的问题。
其实刚才的例子里也展示了组合函数/复合函数的使用例子。 `x1(x2(y))` 等同于 `f(g(x))` 。


## 不变性(Immutability)

一个具有不变性的对象在被创建之后就无法改变它，相反的，具有可变性的对象在创建后是可以改变它的。

不变性是函数式编程的核心理念，因为如果缺少了它，会造成程序中的数据流的混乱。

在JavaScript中，千万不要被 `const` 这个关键词所迷惑，不能简单地认为它声明的变量就是不可变的。实际上 `const` 声明的变量在创建之后是无法再次赋值，而不意味着它不可变。譬如你使用 `const` 创建了一个对象变量，你无法再将这个变量赋值为其他的对象，但是你可以改变这个对象的属性。

```js
const obj = {
  a: 1
}

// obj = { b: 2 } // Uncaught TypeError: Assignment to constant variable

obj.a = 2 // 2
```

JavaScript中有一个对象方法 - `Object.freeze` 可以用于冻结对象的第一层属性，防止其发生变化。

```js
const a = Object.freeze({
  foo: 'Hello',
  bar: 'world',
  baz: '!'
})

a.foo = 'Goodbye'

console.log(a.foo)  // Hello
```

实际上冻结对象只是表面上的对象不可变。

```js
const a = Object.freeze({
  foo: { greeting: 'Hello' },
  bar: 'world',
  baz: '!'
})

a.foo.greeting = 'Goodbye'

console.log(a.foo.greeting) // Goodbye
```

可以看到，在冻结对象的第一层属性为基本类型确实无法改变它，但是如果属性为引用类型时，它仍然是可以改变的。除非你遍历对象所有属性，否则它仍然是可变的。

在很多函数式编程语言中，这种特别的数据结构被称作 `trie data structures`，一种特别有效的深度冻结，即任何属性都无法改变，无论这些属性在对象的第几层级。

Tries使用了结构共享来共享引用的内存地址来达到对象的所有属性能够在复制对象后保持不变，这样就能占用较少的内存空间，并对某些操作有显著的性能改进。

譬如，你可以在对象树的根部使用标识对比来进行比较。如果标识是一样的，你不需要遍历整个树来检查是否有不同的地方。

这种数据结构的思想在 `Immutable.js` 中有深刻地体现。

## 副作用(Side Effects)

副作用是指程序中存在除了函数返回的值还造成了其他的值的变化。其中包括：

* 修改任何外部变量或对象属性（譬如全局变量或夫函数作用域链中的变量）
* 登录终端
* 屏幕输出
* 写文件
* 网络输出
* 触发任何外部程序
* 调用任何带有副作用的函数

将副作用尽可能地移除可以使得程序更易懂、拓展、重构、调式、测试和维护。

这就是为什么大部分前端框架鼓励用户在独立的、弱耦合地模块中管理状态和渲染组件。

## 高阶函数中的可复用性(Reusability Through Higher Order Functions)

函数式编程旨在重用一系列通用地函数来处理数据，面向对象编程旨在对象中共存方法和数据。面向对象中的方法大部分是用于特定的类型，并且是特定对象的数据的处理。

在函数式编程中，任何数据类型都一视同仁。譬如 `map()` 方法可以遍历对象，字符串，数字或任何其他的类型；因为它将函数作为处理给定数据类型的参数。同时，函数式编程通过使用高阶函数来给函数提纯。

那什么是高阶函数呢？高阶函数是至少满足下列一个条件的函数：

* 接受一个或多个函数作为输入
* 输出一个函数

高阶函数常用于以下地方：

* 使用回调、Promise等方法来抽象或隔离操作、效果作用或异步流程控制。
* 创建可以处理各种数据类型的程序
* 将函数柯里化(curry function)来达到复用或复合函数的目的。


## 总结
* 使用纯函数而非共享状态和副作用
* 保持不变性
* 使用复合函数/函数组合而非命令式编程
* 使用复用性高的高阶函数而非使用只能处理特定对象数据的方法来处理不同的数据类型。
* 写声明式的代码而非命令式的代码（更多的是做什么而非该怎么做）
